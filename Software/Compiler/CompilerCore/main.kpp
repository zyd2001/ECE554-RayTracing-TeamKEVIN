const int width;
const int height;
const float epsilon;
const float fov;
const vector camera_location;
const vector camera_lookat_pos;
const vector camera_up;
const vector sky_horizon_color;
const vector sky_top_color;
const vector ambient_light;

const int light_start_address;
const int material_address;

void main(int id, int stackBase)
{
    vector *result;
    result = stackBase + 65520;

    if (id == 0)
        result[0] = [ width, height, epsilon, fov ];
    else if (id == 1)
        result[0] = camera_location;
    else if (id == 2)
        result[0] = camera_lookat_pos;
    else if (id == 3)
        result[0] = camera_up;
    else if (id == 4)
        result[0] = sky_horizon_color;
    else if (id == 5)
        result[0] = sky_top_color;
    else if (id == 6)
        result[0] = ambient_light;
    else if (id == 7)
        result[0] = [ light_start_address, material_address, 0, 0 ];
    else if (id == 8)
    {
        float *ptr;
        ptr = light_start_address;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 9)
    {
        float *ptr;
        ptr = light_start_address + 16;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 10)
    {
        float *ptr;
        ptr = light_start_address + 32;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 11)
    {
        float *ptr;
        ptr = light_start_address + 48;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 12)
    {
        float *ptr;
        ptr = light_start_address + 64;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 13)
    {
        float *ptr;
        ptr = material_address;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 14)
    {
        float *ptr;
        ptr = material_address + 16;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 15)
    {
        float *ptr;
        ptr = material_address + 32;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 16)
    {
        float *ptr;
        ptr = material_address + 48;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else if (id == 17)
    {
        float *ptr;
        ptr = material_address + 64;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }
    else
    {
        float *ptr;
        ptr = material_address + 80;
        result[0] = [ ptr[0], ptr[1], ptr[2], ptr[3] ];
    }

    return;
}

// vector hit_shader(vector origin, vector dir, vector hit, vector normal, int material_number)
// {
//     vector hit_color = [ 0, 0, 0, 0 ];
//     vector ambient_light = [ 0.8, 0.8, 0.8, 1.0 ];
//     // vector *light_position;
//     // light_position = light_start_address;
//     // vector light_origin = light_position[0];
//     // vector one = [ 1, 1, 1, 1 ];

//     // vector *material;
//     // material = material_start_address + (material_number - 1) * 24;
//     vector subsurface_albedo = [ 0, 1.0, 1.0, 1.0 ];
//     // float *RM;
//     // RM = asInt(material) + 16;
//     float roughness = 1.0;
//     // RM = asInt(RM) + 4;
//     float metallic = 1.0;

//     // while (light_origin[3] > 0 && asInt(light_position) < 1073742336)
//     // {
//     //     vector light_color = light_position[1];
//     //     light_position = asInt(light_position) + 32;

//     //     float light_range = light_origin[3];
//     //     light_origin[3] = 0;

//     //     vector light_ray = light_origin - hit;
//     //     float light_distance = sqrt(reduce(light_ray * light_ray));
//     //     vector light_center = light_origin;
//     //     light_origin = light_position[0];

//     //     light_ray = normalize(light_ray);
//     //     float NdL = dot(normal, light_ray);

//     //     // if the light shine on the surface
//     //     if (NdL < 0)
//     //         continue;

//     //     vector shadow_hit, shadow_normal;
//     //     // make sure we can see the light
//     //     shadow_hit, shadow_normal = trace(hit, light_ray);

//     //     float hit_error = distance(shadow_hit, origin) + distance(shadow_hit, light_center);

//     //     // If there is no hit, then we dont care
//     //     if (asInt(shadow_hit[3]) != 0 && (hit_error - light_distance > epsilon || hit_error - light_distance < -epsilon))
//     //         continue;

//     //     float point_light_falloff = (light_range * light_range / (light_distance * light_distance + light_range * light_range));
//     //     light_color = light_color * point_light_falloff;

//     //     vector halfway = normalize(light_ray - dir);
//     //     float NdV = dot(normal, -dir);
//     //     float NdH = dot(normal, halfway);
//     //     float VdH = dot(-dir, halfway);

//     //     vector default_dielectrics_F0 = [ 0.04, 0.04, 0.04, 1 ];
//     //     vector F = subsurface_albedo * metallic + default_dielectrics_F0 * (1 - metallic);
//     //     subsurface_albedo = subsurface_albedo * (1 - metallic);

//     //     hit_color = hit_color + (one - F) * subsurface_albedo * light_color;
//     //     float D = NormalDist(NdH, roughness);       // 1/pi omitted
//     //     float G = HammonSmith(NdV, NdL, roughness); // 4  * NdV * NdL omitted
//     //     vector f_ct = F * D * G;
//     //     hit_color = hit_color + f_ct * light_color;
//     // }

//     float NdV = dot(normal, -dir);

//     return hit_color + ambient_light * subsurface_albedo * NdV;
// }

// float NormalDist(float NdH, float roughness)
// {
//     float rough_sqr = roughness * roughness;
//     float den_2 = NdH * NdH * (rough_sqr - 1.0) + 1.0;
//     float denominator = den_2 * den_2;
//     return rough_sqr / denominator;
// }

// float HammonSmith(float NdV, float NdL, float roughness)
// {
//     if (NdL < 0)
//         NdL = -NdL;
//     if (NdV < 0)
//         NdV = -NdV;

//     float denominator = 2 * NdV * NdL * (1 - roughness) + roughness * (NdL + NdV);
//     return 0.5 / denominator;
// }

// float distance(vector v1, vector v2)
// {
//     return sqrt(reduce((v1 - v2) * (v1 - v2)));
// }

// vector miss_shader(vector origin, vector dir, vector hit, vector normal)
// {
//     vector sky_horizon_color = [ 0.76, 0.765, 0.827, 1 ];
//     vector sky_top_color = [ 0.53, 0.808, 0.92, 1 ];
//     float mix = max(0, dir[1]);
//     return sky_top_color * mix + sky_horizon_color * (1.0 - mix);
// }

// float max(float a, float b)
// {
//     if (a > b)
//         return a;
//     else
//         return b;
//     return a;
// }

// vector normalize(vector v)
// {
//     float norm = sqrt(reduce(v * v));
//     return v / norm;
// }

float dot(vector v1, vector v2)
{
    return reduce(v1 * v2);
}

// Only the first three index matters
// vector cross(vector v1, vector v2)
// {
//     float v10 = v1[0], v11 = v1[1], v12 = v1[2];
//     float v20 = v2[0], v21 = v2[1], v22 = v2[2];

//     float x = v11 * v22 - v12 * v21;
//     float y = v12 * v20 - v10 * v22;
//     float z = v10 * v21 - v11 * v20;
//     vector result = [ x, y, z, 0 ];
//     return result;
// }