const int width = 1280;
const float epsilon = 0.001;
const int height = 720;
// Assume Horizontal Fov is 90 degree, so tan(90/2) = 1
const float fov = 1;
const vector camera_location = [0,0,0,0];
const vector camera_lookat_pos = [0,0,-1,0];
const vector camera_up = [0,1,0,1];
const vector sky_horizon_color = [0.76, 0.765, 0.827, 1];
const vector sky_top_color = [0.53, 0.808, 0.92, 1];

const int light_start_address = 0x40000100;
const int material_start_address = 0x40000200;

// Lights data starts at 0x40000100
// Lighting data mapping, assuming all lights are point light:
// Each light takes two vectors, at most 8 lights
// 0x40000100 Light1, 0x40000120 Light2
// 0x40000100: Light1 Vector1 - position + range 
// 0x40000110: Light1 Vector2 - Light color 
// 0x40000120: Light2 ... 

// for example
0x40000100 = [100,100,100, 10000];
0x40000110 = [1,1,1,1];

// Material data starts at 0x40000200
// Each material takes one vector and two scalar. 
// 0x40000200: Material1 Vector1 - subsurface albedo (aka base color)
// 0x40000210: Material1 Scalar1 Roughness
// 0x40000214: Material1 Scalar1 Metallic
// 0x40000218: Material2 ...
// [0, 0, 1, 1]
// 0
// 1
void main(int id, int stackBase)
{   
    float *result;
    result = stackBase + 65520;
    
    int screen_y = id / width;
    int screen_x = id % width;

    float aspect_ratio_inverse = float(height) / float(width);

    float camera_y = (1 - ((float(screen_y) + 0.5) / float(height)) * 2) * aspect_ratio_inverse;
    float camera_x = 2 * ((float(screen_x) + 0.5) / float(width)) - 1;

    float camera_y = camera_y * fov;
    float camera_x = camera_x * fov;

    vector forward = normalize(camera_location - camera_lookat_pos);
    vector right = cross(camera_up, forward);
    vector up = cross(forward, right);

    vector camera_dir = -forward + right * camera_x + up * camera_y + camera_location;
    camera_dir[3] = 0;
    camera_dir = normalize(camera_dir);

    vector hit, normal;
    hit, normal = trace(orig, camera_dir);
    vector shaded_color;


    shaded_color[3] = 1;
    result* = shaded_color;
}

vector hit_shader(vector origin, vector dir, vector hit, vector normal, int material_number) {
    vector hit_color = [0, 0, 0, 0];
    vector ambient_light = [0.2, 0.2, 0.2, 0.2];
    vector *light_position;
    light_position = light_start_address;
    vector light_origin = light_position*;
    vector one = [1, 1, 1, 1];

    vector *material;
    material = material_start_address + (material_number - 1) * 24;
    vector subsurface_albedo = material*;
    float *RM = material + 16;
    float roughness = RM*;
    RM = RM + 4;
    float metallic = RM*;

    while (light_origin[3] > 0 && light_position <  0x40000200) {
        vector light_color = (light_position+16)*;
        light_position = light_position+32;
        
        float light_range = light_origin[3];
        light_origin[3] = 0;

        vector light_ray = (light_origin - hit);
        float light_distance = sqrt(reduce(light_ray*light_ray));
        vector light_center = light_origin;
        light_origin = light_position*;

        light_ray = normalize(light_ray);
        float NdL = dot(normal, light_ray);

        // if the light shine on the surface
        if (NdL < 0 ) continue;

        vector shadow_hit, shadow_normal;
        // make sure we can see the light
        shadow_hit, shadow_normal = trace(hit+ normal * 0.0001, light_ray);

        float hit_error = distance(shadow_hit, origin) + distance(shadow_hit, light_center);
        
        // If there is no hit, then we dont care
        if (asInt(shadow_hit[3]) != 0 && (hit_error - light_distance > epsilon || hit_error - light_distance < -epsilon)) continue;

        float point_light_falloff = (light_range * light_range / (light_distance * light_distance + light_range * light_range));
        vector light_color = light_color * point_light_falloff;

        vector halfway = normalize(light_ray - dir);
        float NdV = dot(normal, -dir);
        float NdH = dot(normal, halfway);
        float VdH = dot(-dir, halfway);


        vector default_dielectrics_F0 = [0.04, 0.04, 0.04, 1];
        vector F = metallic * subsurface_albedo + (1 - metallic) * default_dielectrics_F0;
        subsurface_albedo = (1 - metallic) * subsurface_albedo; 
        
        hit_color = hit_color + (one - F) * subsurface_albedo * light_color;
        float D = NormalDist(NdH, roughness);        // 1/pi omitted
        float G = HammonSmith(NdV, NdL, roughness);  // 4  * NdV * NdL omitted
        vector f_ct = F * D * G;
        hit_color = hit_color + f_ct * light_color;
    }

    float NdV = dot(normal, -dir);

    diffuse_color = diffuse_color + ambient_light * subsurface_albedo * NdV;
                            

}
float NormalDist(float NdH, float roughness) {
    float rough_sqr = roughness * roughness;
    float den_2 = NdH * NdH * (rough_sqr - 1) + 1;
    float denominator = den_2 * den_2;
    return rough_sqr / denominator;
}

float HammonSmith(float NdV, float NdL, float roughness) {
    if (NdL < 0) NdL = -NdL;
    if (NdV < 0) NdV = -NdV;

    float denominator = 2 * NdV * NdL * (1-roughness) + roughness * ( NdL + NdV);
    return 0.5 / denominator;
}


float distance(vector v1, vector v2) {
    return sqrt(reduce((v1-v2)*(v1-v2)));
}

vector miss_shader(vector origin, vector dir, vector hit, vector normal) {
    float mix = max(0, dir[1]);
    return (mix * sky_top_color + (1-mix) * sky_horizon_color)
}


float max(float a, float b) {
    if (a > b) return a;
    else return b;

}


vector normalize(vector v)
{
    vector norm = sqrt(reduce(v*v));
    return v / norm;
}


float dot(vector v1, vector v2) {
    return reduce(v1 * v2);
}

// Only the first three index matters
vector cross(vector v1, vector v2) {
    float x = v1[1] * v2[2] - v1[2] * v2[1];
    float y = v1[2] * v2[0] - v1[0] * v2[2];
    float z = v1[0] * v2[1] - v1[1] * v2[0];
    vector result = [x, y, z, 0];
    return result;
}